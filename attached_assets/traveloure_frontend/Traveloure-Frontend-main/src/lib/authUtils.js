// Centralized authentication utilities for handling token expiration and logout

// Global reference to NextAuth signOut function
let globalSignOutFunction = null

/**
 * Register the NextAuth signOut function globally
 * Call this from your root component/layout
 * @param {function} signOutFn - NextAuth signOut function
 */
export const registerSignOut = (signOutFn) => {
  globalSignOutFunction = signOutFn
  console.log('ðŸ”’ NextAuth signOut function registered')
}

/**
 * Get the registered signOut function
 * @returns {function|null} - The registered signOut function or null
 */
export const getSignOutFunction = () => {
  return globalSignOutFunction
}

/**
 * Check if the error response indicates token expiration
 * @param {Object} errorData - Error response data
 * @returns {boolean} - True if token is expired
 */
export const isTokenExpired = (errorData) => {
  if (!errorData) return false
  
  // Check for the specific token expired error format
  // Format: { code: "token_not_valid", detail: "Given token not valid for any token type", messages: [...] }
  if (errorData.code === 'token_not_valid') {
    // Check detail message - this is a strong indicator
    if (errorData.detail === 'Given token not valid for any token type') {
      return true
    }
    
    // Check messages array for token expiration
    if (errorData.messages && Array.isArray(errorData.messages)) {
      const hasExpiredMessage = errorData.messages.some(msg => {
        // Check for "Token is expired" message (exact match)
        if (msg.message === 'Token is expired') {
          return true
        }
        // Check for access token type with expired status
        if (msg.token_type === 'access' && msg.message && msg.message.toLowerCase().includes('expired')) {
          return true
        }
        // Check token_class
        if (msg.token_class === 'AccessToken' && msg.message && msg.message.toLowerCase().includes('expired')) {
          return true
        }
        // Check for any message containing "expired" with AccessToken
        if (msg.token_class === 'AccessToken' && msg.token_type === 'access') {
          const msgText = (msg.message || '').toLowerCase()
          if (msgText.includes('expired') || msgText.includes('invalid') || msgText.includes('not valid')) {
            return true
          }
        }
        return false
      })
      
      if (hasExpiredMessage) {
        return true
      }
    }
    
    // If code is token_not_valid, it's likely expired even without specific messages
    // This is a fallback for cases where the error format might vary slightly
    return true
  }
  
  // Check messages array directly (in case code is missing)
  if (errorData.messages && Array.isArray(errorData.messages)) {
    const hasExpiredMessage = errorData.messages.some(msg => {
      if (msg.message === 'Token is expired') {
        return true
      }
      if (msg.token_type === 'access' && msg.message && msg.message.toLowerCase().includes('expired')) {
        return true
      }
      if (msg.token_class === 'AccessToken' && msg.message && msg.message.toLowerCase().includes('expired')) {
        return true
      }
      // Check for AccessToken with any error message
      if (msg.token_class === 'AccessToken' && msg.token_type === 'access') {
        const msgText = (msg.message || '').toLowerCase()
        if (msgText.includes('expired') || msgText.includes('invalid') || msgText.includes('not valid')) {
          return true
        }
      }
      return false
    })
    
    if (hasExpiredMessage) {
      return true
    }
  }
  
  // Additional checks for common token expiration messages
  if (errorData.detail && typeof errorData.detail === 'string') {
    const detail = errorData.detail.toLowerCase()
    if (detail.includes('token') && (
      detail.includes('expired') || 
      detail.includes('invalid') || 
      detail.includes('not valid')
    )) {
      return true
    }
  }
  
  // Check error message field
  if (errorData.message && typeof errorData.message === 'string') {
    const message = errorData.message.toLowerCase()
    if (message.includes('token') && (
      message.includes('expired') || 
      message.includes('invalid') || 
      message.includes('not valid')
    )) {
      return true
    }
  }
  
  return false
}

/**
 * Get the appropriate redirect URL based on current path
 * @param {string} currentPath - Current pathname
 * @returns {string} - Redirect URL
 */
export const getRedirectUrl = (currentPath) => {
  if (!currentPath) return '/login'
  
  // Check which panel the user is in
  if (currentPath.startsWith('/admin')) {
    return '/login' // Admin panel -> login page
  } else if (currentPath.startsWith('/service-provider-panel')) {
    return '/login' // Service provider -> login page
  } else if (currentPath.startsWith('/local-expert')) {
    return '/login' // Local expert -> login page
  } else if (currentPath.startsWith('/dashboard')) {
    return '/login' // User dashboard -> login page
  } else if (currentPath.startsWith('/help-me-decide')) {
    return '/login' // Help me decide -> login page
  }
  
  // Default to login page for authenticated routes
  // Only redirect to home for public routes
  return '/login'
}

/**
 * Clear all authentication data from localStorage
 */
export const clearAuthData = () => {
  localStorage.removeItem('accessToken')
  localStorage.removeItem('refreshToken')
  localStorage.removeItem('userData')
  
  // Clear any other session-related data if needed
  // Add more items here if your app stores additional auth data
}

/**
 * Handle token expiration - logout and redirect
 * @param {string} currentPath - Current pathname (optional)
 * @param {function} signOutCallback - NextAuth signOut function (optional, uses global if not provided)
 */
export const handleTokenExpiration = async (currentPath = null, signOutCallback = null) => {
  console.log('ðŸ”’ Token expired - logging out user')
  
  // Clear authentication data from localStorage
  clearAuthData()
  
  // Use provided signOut or fall back to global signOut
  const signOut = signOutCallback || globalSignOutFunction
  
  // Call NextAuth signOut to clear session
  if (signOut && typeof signOut === 'function') {
    try {
      console.log('ðŸ”’ Calling NextAuth signOut to clear session')
      await signOut({ redirect: false }) // Don't let NextAuth redirect, we'll handle it
    } catch (error) {
      console.error('Error calling NextAuth signOut:', error)
    }
  } else {
    console.warn('âš ï¸ No NextAuth signOut function available. Session may not be fully cleared.')
  }
  
  // Get current path from window if not provided
  const path = currentPath || (typeof window !== 'undefined' ? window.location.pathname : '/')
  
  // Get appropriate redirect URL
  const redirectUrl = getRedirectUrl(path)
  
  console.log(`ðŸ”’ Redirecting to: ${redirectUrl}`)
  
  // Redirect to appropriate page
  if (typeof window !== 'undefined') {
    // Small delay to ensure signOut completes
    setTimeout(() => {
      // Use window.location.replace to prevent back button navigation
      window.location.replace(redirectUrl)
    }, 100)
  }
}

/**
 * Create a global event listener for token expiration
 * This can be used to broadcast token expiration across tabs/windows
 */
export const broadcastTokenExpiration = () => {
  if (typeof window !== 'undefined' && window.localStorage) {
    // Trigger storage event for other tabs
    localStorage.setItem('tokenExpired', Date.now().toString())
    localStorage.removeItem('tokenExpired')
  }
}

/**
 * Setup listener for token expiration events from other tabs
 * @param {function} callback - Callback to execute when token expiration is detected
 */
export const setupTokenExpirationListener = (callback) => {
  if (typeof window === 'undefined') return null
  
  const handleStorageChange = (e) => {
    if (e.key === 'tokenExpired' || e.key === 'accessToken') {
      // Check if token was removed
      const accessToken = localStorage.getItem('accessToken')
      if (!accessToken && e.oldValue && !e.newValue) {
        callback()
      }
    }
  }
  
  window.addEventListener('storage', handleStorageChange)
  
  // Return cleanup function
  return () => window.removeEventListener('storage', handleStorageChange)
}

